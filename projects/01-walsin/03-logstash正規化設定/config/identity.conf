input {
  udp {
    port => 10002
#    start_position => "beginning"
    tags => ident
     }
}
filter {
  if "ident" in [tags]{
		grok {
#			break_on_match => true
                        match =>  [				
                                "message" , "<%{NUMBER}>%{CISCOTIMESTAMP:time} %{NOTSPACE:Host} %{NOTSPACE:app}\[%{NUMBER:appID}\]: %{NOTSPACE:info}\: \(%{NOTSPACE:system}\): %{DATA:Status}\;%{SPACE}%{GREEDYDATA:mess}",
                                "message" , "<%{NUMBER}>%{CISCOTIMESTAMP:time} %{NOTSPACE:Host} %{NOTSPACE:app}\[%{NUMBER:appID}\]: %{NOTSPACE:info} \(%{NOTSPACE:useraddress}\) %{DATA:Status}\; %{GREEDYDATA:mess}",
                                "message" , "<%{NUMBER}>%{CISCOTIMESTAMP:time} %{NOTSPACE:Host} %{NOTSPACE:app}\[%{NUMBER:appID}\]:%{SPACE}%{NOTSPACE:ID}\:%{SPACE}to=\<%{NOTSPACE:toMail}\>,%{SPACE}%{GREEDYDATA:mess}",
                                "message" , "<%{NUMBER}>%{CISCOTIMESTAMP:time} %{NOTSPACE:Host} %{NOTSPACE:app}: %{NOTSPACE:info} \(%{NOTSPACE:useraddress}\) %{DATA:Status}\; %{GREEDYDATA:mess}",
                                "message" , "<%{NUMBER}>%{CISCOTIMESTAMP:time} %{NOTSPACE:Host} %{NOTSPACE:app}\[%{NUMBER:appID}\]: %{DATA:Status}\; %{GREEDYDATA:mess}",
                                "message" , "<%{NUMBER}>%{CISCOTIMESTAMP:time} %{NOTSPACE:Host} %{NOTSPACE:app}\[%{NUMBER:appID}\]: %{GREEDYDATA:msg}",
                                "message" , "<%{NUMBER}>%{CISCOTIMESTAMP:time} %{NOTSPACE:Host} %{NOTSPACE:app}\: %{GREEDYDATA:msg}",
                                "message" , "%{GREEDYDATA:nf_msg}" ]
                	named_captures_only => true
			}

        mutate {
            add_field => { "current_time" => "%{+YYYYMMdd HH:mm:ss} " }
        }

		if [msg] {
		    grok {
 			match =>  ["msg" , "Sending email from %{GREEDYDATA:fromMail} to %{GREEDYDATA:toMail}"]
			}
		}
		if [Status] =~ "Authentication" { 
			grok { match =>[ "Status" , "%{GREEDYDATA} %{WORD:Authentication}" ] } 
		} elseif [Status] =~ "SFTP" {
			grok { match =>[ "Status" , "%{GREEDYDATA} %{WORD:SFTP_file}" ] }
		} elseif [Status] =~ "connection" {
                        grok { match =>[ 
					 "Status" , "Server connection %{WORD:connection_status}",
					 "Status" , "%{WORD:connection_status} connection",
					 "status" , "%{GREEDYDATA:nf_connection}"
			 ]
			 named_captures_only => true
		 }
                }
		if [mess] !~ ";" {
		    kv {
			source => "mess"
			field_split => ", "
			value_split => "="
		    }
		}
#		kv {
#			source => "mess1"
#			field_split => ";"
#			value_split => '='
#		}

#		mutate {
#			add_field => { "timestamp" => "%{date} %{time}" }
#		}

		date {
			timezone => "Asia/Taipei"
			match => [ "time", "MMM dd HH:mm:ss","MMM d HH:mm:ss"]
		}

        ruby {
            code => "event.set('index_time', event.get('[@timestamp]').time.localtime.strftime('%Y_%m'))"
        }
        ruby {
            code => "event.set('file_time', event.get('[@timestamp]').time.localtime.strftime('%Y%m%d'))"
        }
        if [client_ip] {
            mutate {
                add_field => {"sourceAddress" => "%{client_ip}" }
            }
        }

        translate {
            field => "host"
            destination => "host_OU"
            dictionary_path => '/home/disney/bin/Yaml/Identity.yaml'
            refresh_interval => 60
            }
        translate {
            field => "sourceAddress"
            destination => "sourceMID-mapping"
            dictionary_path => '/home/disney/bin/Yaml/IPMIDName-Mapping.yaml'
            refresh_interval => 60
            }
 csv {
      separator => ","
      source => "sourceMID-mapping"
      columns => ["Source_empId","Source_computer_host_name","Source_os_version","Source_useless","Source_client_user_name","Source_costnam","Source_client_BG","Source_client_BU","Source_client_OU","Source_client_status"]
  }


#		mutate {
#			remove_field => [ "mess" ]
#		}

  }
}
output {
  if "ident" in [tags] {
       elasticsearch {
       hosts => ["10.190.253.45:9200"]
       index => "logstash-identity-walsin-%{index_time}"
#       user => "elastic"
#       password => "12345678"
        }
#       elasticsearch {
#       hosts => ["10.190.253.88:9200"]
#       index => "logstash-identity-walsin-%{index_time}"
#       user => "elastic"
#       password => "12345678"
#        }
        file {
            path => "/data/logstash_data_backup/logstash_data/DailyDownload/identity-%{file_time}.log"
            codec => line {format => "%{message}"}
          }
#        stdout { codec => rubydebug }
  }
}

