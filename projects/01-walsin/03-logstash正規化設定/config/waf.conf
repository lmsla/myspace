input {
  udp {
    port => 10003
#    start_position => "beginning"
    codec => cef {
   raw_data_field => raw_data_field
  }

    tags => waf
     }
}

filter {
  if "waf" in [tags] {
    ruby {
      code => "
        dcList = Array[]
        result = Hash.new
        logEvent = event.to_hash
        logEvent.each do |k,v|
          if /Label$/ =~ k

          elsif /^deviceCustom/ =~ k
              dcList.push(k)
          end
        end
        dcList.each do |dcele|
          dcLabelKey = dcele + 'Label'
          result.store(event.get(dcLabelKey), event.get(dcele))
        end
        result.each do |k,v|
          event.set(k, v)
        end
      "
    }

    ruby {
      code => "
        dcList = Array[]
        result = Hash.new
        logEvent = event.to_hash
        logEvent.each do |k,v|
          if /Label$/ =~ k

          elsif /^cn/ =~ k
            dcList.push(k)
          end
        end
        dcList.each do |dcele|
          dcLabelKey = dcele + 'Label'
          result.store(event.get(dcLabelKey), event.get(dcele))
        end
        result.each do |k,v|
          event.set(k, v)
        end
      "
    }

    ruby {
      code => "
        dcList = Array[]
        result = Hash.new
        logEvent = event.to_hash
        logEvent.each do |k,v|
          if /Label$/ =~ k

          elsif /^cs/ =~ k
            dcList.push(k)
          end
        end
        dcList.each do |dcele|
          dcLabelKey = dcele + 'Label'
          result.store(event.get(dcLabelKey), event.get(dcele))
        end
        result.each do |k,v|
          event.set(k, v)
        end
      "
    }

    ruby {
      code => "
        dcList = Array[]
        result = Hash.new
        logEvent = event.to_hash
        logEvent.each do |k,v|
          if /Label$/ =~ k

          elsif /^flexNumber/ =~ k
            dcList.push(k)
          end
        end
        dcList.each do |dcele|
          dcLabelKey = dcele + 'Label'
          result.store(event.get(dcLabelKey), event.get(dcele))
        end
        result.each do |k,v|
          event.set(k, v)
        end
      "
    }

    mutate{
      convert =>{
        "sequencenum" => "integer"
      }
    }

    date{
      match => ["deviceReceiptTime","MMM dd YYYY HH:mm:ss"]
      timezone => "Asia/Taipei"
#      target => "receiptime"
    }

    geoip{
      source =>"sourceAddress"
	  target =>"src_geoip"
    }
    geoip{
      source =>"destinationAddress"
	  target =>"dest_geoip"
    }
    mutate {
	add_field => {"ip_client" => "%{sourceAddress}" }
	add_field => {"dest_ip" => "%{destinationAddress}" }
	}
    mutate {
      rename => {"destinationPort" => "dest_port"}
      rename => {"deviceAction" => "request_status"}
      rename => {"name" => "violations"}
      rename => {"method" => "requestMethod"}
      rename => {"deviceHostName" => "url"}
      rename => {"requestUrl" => "uri"}
      rename => {"requestMethod" => "method"}
    }

    mutate {
      add_field => { "response_code(int)" => "%{response_code}" }
      add_field => { "attack_type_split" => "%{attack_type}" }
#      add_field => { "client_type" => "" }
    }

    mutate {
      convert => { "response_code(int)" => "integer" }
    }
   
    mutate{
      split => ["attack_type_split", ","]
    }
        ruby {
            code => "event.set('index_time', event.get('[@timestamp]').time.localtime.strftime('%Y_%m'))"
        }
        ruby {
            code => "event.set('file_time', event.get('[@timestamp]').time.localtime.strftime('%Y%m%d'))"
        }


  }
}  

output {
  if "waf" in [tags] {
    elasticsearch {
    hosts => ["10.190.253.45:9200"]
    index => "logstash-waf-walsin-%{index_time}"
#   user => elastic
#   password => "12345678"
    }
#    elasticsearch {
#    hosts => ["10.190.253.88:9200"]
#    index => "logstash-waf-walsin-%{index_time}"
#   user => elastic
#   password => "12345678"
#    }
      file {
	     path => "/data/logstash_data_backup/logstash_data/DailyDownload/waf-%{file_time}.log"
	     codec => line {format => "%{raw_data_field}"}
  }
}
}
