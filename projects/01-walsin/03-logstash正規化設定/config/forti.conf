input {
  udp {
    port => 10007
#    start_position => "beginning"
    tags => forti
     }
}


filter {
  if "forti" in [tags] {
    if [message] =~ "date" {
        mutate {
            add_field => { "current_time" => "%{+YYYYMMdd HH:mm:ss} " }
        }
      mutate {
        add_tag => [ "forti", "pars" ]
#        add_field => { "deviceName" => "Fortigate" }
      }
#	grok {
#      match =>  ["message" , "%{NUMBER} <%{NUMBER}>%{NUMBER} %{TIMESTAMP_ISO8601:time} %{IP:host_ip} - - - - <%{NUMBER}>%{GREEDYDATA:forti_msg}",
#				 "message" , "%{DATA:data} %{CISCOTIMESTAMP:time} %{IP:host_ip} - - - - <%{NUMBER}>%{GREEDYDATA:forti_msg}",
#				 "message" , "%{GREEDYDATA:nf_msg}"
#		]
#    }
		grok {
			match =>  ["message" , "<%{INT}>%{GREEDYDATA:mess}"]
		}

		kv {
			source => "mess"
			field_split => " "
            value_split => "="
		}

#			if [message] =~ "user=" {
#				if ![user] {
#					mutate {
#						add_field => { "user" => "null" }	
#					}	
#				}		
#			}

		mutate {
			add_field => { "timestamp" => "%{date} %{time}" }
		}

		date {
			timezone => "Asia/Taipei"
			match => [ "timestamp", "YYYY-MM-dd HH:mm:ss" ]
		}

#		mutate {
#			remove_field => [ "mess" ]
#		}

		mutate {
			rename => { "srcport" => "sourcePort" }
			rename => { "srcip" => "sourceAddress" }
			rename => { "srcmac" => "sourceMacAddress" } 
			rename => { "dstip" => "destinationAddress" }
			rename => { "dstport" => "destinationPort" }
			rename => { "srccountry" => "src_country" }
			rename => { "dstcountry" => "dest_country" }
			rename => { "srcintf" => "src_intf" }
			rename => { "dstintf" => "dest_intf" }
			rename => { "rcvdbyte" => "bytes_in" }
			rename => { "sentpkt" => "packets_out" }
			rename => { "rcvdpkt" => "packets_in" }
			rename => { "sentbyte" => "bytes_out" }
		}

		if [rcvddelta] {
			mutate {
				add_field => { "bytes_in_difference" => "%{rcvddelta}" }	
			}	
		}		

		if [sentdelta] {
			mutate {
				add_field => { "bytes_out_difference" => "%{sentdelta}" }	
			}	
		}		

		geoip {
		    source => "sourceAddress"
			target => "src_geoip"
    	}

	  geoip {
	    source => "destinationAddress"
			target => "dest_geoip"
	  }

		if [user] and [sourceAddress] {
			mutate {
				add_field => { "[@metadata][user_ip]" => "%{user},%{sourceAddress}" }	
			}
		}

		if [sentdelta] and [rcvddelta] {
			ruby {
				code => "
					event.set('bytes_difference', event.get('sentdelta').to_i + event.get('rcvddelta').to_i)
				"
			}
		}

		if [bytes_in] and [bytes_out] {
			ruby {
				code => "
					event.set('bytes', event.get('bytes_in').to_i + event.get('bytes_out').to_i)
				"
			}
		}

		if [packets_in] and [packets_out] {
			ruby {
				code => "
					event.set('packets', event.get('packets_in').to_i + event.get('packets_out').to_i)
				"
			}
		}

		if [duration] == 0  and [bytes] == 0 {
			mutate {
				add_field => { "bytes per second" => "0" }	
			}
		}

		mutate {
			convert => { "bytes per second" => "float" }
		}

		if [bytes] != 0 and [duration] and [bytes] {
			ruby {
				code => "
					event.set('bytes per second', event.get('bytes').to_f / (event.get('duration').to_f + 1)).to_f
				"
			}
		}

#		if [subtype] == "vpn" {	
#			mutate {
#				add_field => { "sourceAddress" => "%{remip}" }
#				add_field => { "dest_ip" => "%{locip}" }
#			}
#		}

		if [bytes_difference] {
			mutate {
				add_field => { "real_bytes" => "%{bytes_difference}" }
				add_field => { "real_bytes_in" => "%{bytes_in_difference}" }
				add_field => { "real_bytes_out" => "%{bytes_out_difference}" }
			}
		} 

		if ![bytes_difference] and [bytes] {
			mutate {
				add_field => { "real_bytes" => "%{bytes}" }
				add_field => { "real_bytes_in" => "%{bytes_in}" }
				add_field => { "real_bytes_out" => "%{bytes_out}" }
			}
		} 

    translate   {
      field => "proto"
      destination => "protocol"
      dictionary_path => '/etc/logstash/yaml/Protocol.yaml'
    }

		mutate {
			convert => { "bytes" => "integer" }
			convert => { "bytes_in" => "integer" }
			convert => { "bytes_out" => "integer" }
			convert => { "packets_in" => "integer" }
			convert => { "packets_out" => "integer" }
			convert => { "packets" => "integer" }
			convert => { "duration" => "integer" }
			convert => { "bytes per second" => "float" }
			convert => { "bytes_difference" => "integer" }
			convert => { "bytes_out_difference" => "integer" }
			convert => { "bytes_in_difference" => "integer" }
			convert => { "real_bytes" => "integer" }
			convert => { "real_bytes_in" => "integer" }
			convert => { "real_bytes_out" => "integer" }
		}

		mutate {
			rename => { "bytes_in" => "original_bytesIn" }
			rename => { "bytes_out" => "original_bytesOut" }
			rename => { "bytes" => "original_bytesTotal" }
			rename => { "real_bytes_in" => "bytesIn" }
			rename => { "real_bytes_out" => "bytesOut" }
			rename => { "real_bytes" => "bytesTotal" }
		}
        ruby {
			code => "event.set('index_time', event.get('[@timestamp]').time.localtime.strftime('%Y_%m_%d'))"
        }
        ruby {
			code => "event.set('file_time', event.get('[@timestamp]').time.localtime.strftime('%Y%m%d'))"
        }
		if [sourceAddress] {
        cidr {
            add_field => { "sourceSubnet" => "內網" }
            address => [ "%{sourceAddress}" ]
            network => [ "10.0.0.0/8" ]
      }
        cidr {
            add_field => { "sourceSubnet" => "內網" }
            address => [ "%{sourceAddress}" ]
            network => [ "172.16.0.0/12" ]
      }
        cidr {
            add_field => { "sourceSubnet" => "內網" }
            address => [ "%{sourceAddress}" ]
            network => [ "192.168.0.0/16" ]
      }
	}
		if [destinationAddress] {
        cidr {
            add_field => { "destinationSubnet" => "內網" }
            address => [ "%{destinationAddress}" ]
            network => [ "10.0.0.0/8" ]
      }
        cidr {
            add_field => { "destinationSubnet" => "內網" }
            address => [ "%{destinationAddress}" ]
            network => [ "172.16.0.0/12" ]
      }
        cidr {
            add_field => { "destinationSubnet" => "內網" }
            address => [ "%{destinationAddress}" ]
            network => [ "192.168.0.0/16" ]
      }
	}
        if [sourceSubnet] != "內網" and [sourceAddress] {
            mutate {
               add_field => { "sourceSubnet" => "外網" }
        }
      }
        if [destinationSubnet] != "內網" and [destinationAddress] {
            mutate {
               add_field => { "destinationSubnet" => "外網" }
        }
      }
        if [sourceSubnet] == "內網" and [destinationSubnet] == "內網" {
           mutate {
               add_field => { "connectionDescription" => "內網連內網" }
           }
       }
        if [sourceSubnet] == "內網" and [destinationSubnet] == "外網" {
           mutate {
               add_field => { "connectionDescription" => "內網連外網" }
           }
       }
        if [sourceSubnet] == "外網" and [destinationSubnet] == "內網" {
           mutate {
               add_field => { "connectionDescription" => "外網連內網" }
           }
       }
        if [sourceSubnet] == "外網" and [destinationSubnet] == "外網" {
           mutate {
               add_field => { "connectionDescription" => "外網連外網" }
           }
       }
        translate {
            field => "host"
            destination => "host_OU"
            dictionary_path => '/home/disney/bin/Yaml/Forti.yaml'
            refresh_interval => 60
            }
        translate {
            field => "sourceAddress"
            destination => "sourceMID-mapping"
            dictionary_path => '/home/disney/bin/Yaml/IPMIDName-Mapping.yaml'
            refresh_interval => 60
            }
        translate {
            field => "destinationAddress"
            destination => "destinationMID-mapping"
            dictionary_path => '/home/disney/bin/Yaml/IPMIDName-Mapping.yaml'
            refresh_interval => 60
            }
 csv {
      separator => ","
      source => "sourceMID-mapping"
      columns => ["Source_empId","Source_computer_host_name","Source_os_version","Source_useless","Source_client_user_name","Source_costnam","Source_client_BG","Source_client_BU","Source_client_OU","Source_client_status"]
  }
 csv {
      separator => ","
      source => "destinationMID-mapping"
	  columns => ["Destination_empId","Destination_computer_host_name","Destination_os_version","Destination_useless","Destination_client_user_name","Destination_costnam","Destination_client_BG","Destination_client_BU","Destination_client_OU","Destination_client_status"
]  
}



	}
  }
}

output {
  if "forti" in [tags] {
    elasticsearch {
      hosts => ["10.190.253.45:9200"]
      index => "logstash-firewall-fortigate-walsin-%{index_time}"
#      user => "elastic"
#      password => "1qaz@WSX"
    }
#     elasticsearch {
#      hosts => ["10.190.253.88:9200"]
#      index => "logstash-firewall-fortigate-walsin-%{index_time}"
#      user => "elastic"
#      password => "1qaz@WSX"
#    }
        file {
            path => "/data/logstash_data_backup/logstash_data/DailyDownload/forti-%{file_time}.log"
            codec => line {format => "%{message}"}
          }
	}
#  stdout { codec => rubydebug }
}

